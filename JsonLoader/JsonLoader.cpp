/****************************************Copyright (c)****************************************************
**
**                                       D.H. InfoTech
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  JsonLoader.cpp
** Latest Version:             V1.0.0
** Latest modified Date:       2016/3/2
** Modified by:                
** Descriptions:               
**
**--------------------------------------------------------------------------------------------------------
** Created by:                 Chen Honghao
** Created date:               2016/3/1
** Descriptions:               JsonLoader class  [Generated by VP-UML, IGT1.0]
** 
*********************************************************************************************************/
#if defined(_MSC_VER) && (_MSC_VER >= 1600)  
# pragma execution_character_set("utf-8")  
#endif

#include "Object.h"
#include "Parser.h"
#include "JsonLoader.h"

#include <QJsonDocument>
#include <QJsonArray>
#include <QJsonObject>
#include <QJsonValue>
#include <QJsonParseError>

#include <QPair>
#include <QQueue>
#include <QStack>
#include <QDir>
#include <QFile>
#include <QDebug>

#include <QtWidgets/QWidget>



/**
 *  @struct IterInfo
 *  @brief  用于遍历JSON各个Value节点的临时数据结构，外部禁止访问
 */
struct IterInfo
{
    ObjectContext* object;
    QString        key;
    QJsonValue     value;
};

/**
 * Constructor
 */
JsonLoader::JsonLoader() : QObject(),
    m_rootObjectContext("JsonLoader", QJsonValue("JsonLoader")),
    m_defaultMetaType(QMetaType::UnknownType),
    m_propertyDependencyMode(JsonLoader::Default)
{
    m_rootObjectContext.setId("JsonLoader");
    m_rootObjectContext.setQObject(this);

    registerObjectCreator(new MetaTypeKeyObjectCreator(this, ".type", ".id"));
    registerObjectCreator(new RefKeyObjectCreator(this, ".ref", ".id"));
#if ENABLE_LEGACY_KEYWORDS
    registerObjectCreator(new MetaTypeKeyObjectCreator(this, "metaType", "id"));
#endif
    // 此处必须保证在使用meta type创建对象的各个ObjectCreator之后，
    // 否则那些ObjectCreator的业务会被这个ObjectCreater抢走
    //registerObjectCreator(new ParentPropertyObjectCreator(this));
    // 由于仅有一个默认对象，可在createQObject函数中直接使用
    //registerObjectCreator(new DefaultTypeObjectCreator(this));

    //registerKeyParser(new IdKeyParser(this));
    registerKeyParser(new PropertyKeyParser(this));
    registerKeyParser(new ChildPropertyKeyParser(this));
    registerKeyParser(new MethodKeyParser(this));
    registerKeyParser(new ConnectionsKeyParser(this));
    registerKeyParser(new ObjectsKeyParser(this));
#if ENABLE_LEGACY_KEYWORDS
    registerKeyParser(new ObjectsKeyParser(this, "objects"));
#endif
    registerKeyParser(new QParentKeyParser(this));
#if ENABLE_LEGACY_KEYWORDS
    registerKeyParser(new QParentKeyParser(this, "qparent"));
#endif
    registerKeyParser(new QChildrenKeyParser(this));
#if ENABLE_LEGACY_KEYWORDS
    registerKeyParser(new QChildrenKeyParser(this, "qchildren"));
#endif
#if ENABLE_LEGACY_KEYWORDS
    registerKeyParser(new ConnectionsKeyParser(this, "connections"));
#endif
    
    int widgetStarMetaTypeId = QMetaType::type("QWidget*");
    if (widgetStarMetaTypeId >= 0)
    registerArrayValueParser(new GenericListValueParser<QWidget*>(this, widgetStarMetaTypeId));
    registerArrayValueParser(new GenericListValueParser<QString>(this, QMetaType::QString));
    registerArrayValueParser(new GenericListValueParser<QObject*>(this, QMetaType::QObjectStar));

    registerStringValueParser(new TranslatedStringValueParser(this));
    registerStringValueParser(new ObjectNameStringValueParser(this));
    registerStringValueParser(new PropertyNameStringValueParser(this));
    registerStringValueParser(new MethodNameStringValueParser(this));
    registerStringValueParser(new EnumNameStringValueParser(this));

    registerStringValueParser(new PixmapStringValueParser(this));
    registerStringValueParser(new SizeStringValueParser(this));
    registerStringValueParser(new RectStringValueParser(this));
    registerStringValueParser(new DateTimeStringValueParser(this));

#if JSON_LOADER_DEBUGGING_LEVEL >= 1
    connect(this, &JsonLoader::error, this, &JsonLoader::reportError);
#endif

#if ENABLE_MEM_POOL
    m_objectContextBuffer.reserve(4096);
#endif
}

JsonLoader::~JsonLoader()
{
    // 目前JsonLoader析构时不会删除已加载的对象，从而保证可以使用局部的临时JsonLoader来加载全局对象
}

/*!
 * 载入内存中的JSON数据（例如来自网络的、代码中的JSON）
 * @param[in]  jsonData             内存中的JSON数据
 * @param[in]  parentContext        该JSON数据的父对象，该JSON中的全部对象将被挂载于父对象下方
 * @param[in]  parentKey            通常需要为该JSON数据指定一个Key，用于标识对象树的主分支
 * @param[in]  possibleObjectList   可能是对象的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @param[in]  jsonObjectList       可能是JSON文件的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @return     加载得到的根对象或根数组
 */
QVariant JsonLoader::load(
    const QByteArray& jsonData, 
    ObjectContext& parentContext, 
    const QString& parentKey,
    QList<ObjectContext*>& possibleObjectList,
    QList<ObjectContext*>& jsonObjectList
    )
{
    if (jsonData.isNull() || jsonData.isEmpty()) 
    {
        emit error(EmptyDocument, QString("Empty JSON document detected, key=%1").arg(parentKey));
        return QVariant();
    }

    QJsonParseError parserError;
    QJsonDocument document = QJsonDocument::fromJson(jsonData, &parserError);
    if (parserError.error != QJsonParseError::NoError)
    {
        QString dumpString = dumpJsonData(jsonData, parserError.offset);
        
        QString errorMessage = parserError.errorString()
            + QString(", offset=%1: \n").arg(parserError.offset)
            + dumpString;
        emit error(parserError.error, errorMessage);
        // 文档出错后仍然尝试解析
        //return QVariant();
    }

    if (document.isNull() || document.isEmpty())
    {
        emit error(InvalidDocument, "Empty JSON document detected");
        return QVariant();
    }

    
    QJsonValue rootJsonValue;
    if (document.isArray()) {
        rootJsonValue = document.array();
    } else if (document.isObject()) {
        rootJsonValue = document.object();
    }
    
    int initialObjectCount = possibleObjectList.size();
    int count = createObjectContextTree(rootJsonValue, parentContext, parentKey, possibleObjectList);
    if (count < 0) {
        emit error(
            ObjectCreatorError,
            QString("Failed to create ObjectContext tree")
            );
    }
    //ObjectContext::dumpObjectContext(parentContext);

    QList<ObjectContext*>::iterator cbegin = possibleObjectList.begin() + initialObjectCount;
    QList<ObjectContext*>::iterator cend = possibleObjectList.end();
    for (QList<ObjectContext*>::iterator iter = cbegin; iter != cend; ++iter)
    {
        bool ok = createQObject(*(*iter));
        //if (!ok) qDebug() << (*iter)->value();
        if (!ok && (*iter)->value().type() == QJsonValue::Object) 
        {
            emit error(
                ObjectCreatorError, 
                QString("Failed to create object for %1").arg((*iter)->toString())
                );
        }
    }
    //ObjectContext::dumpObjectContext(parentContext);

    for (QList<ObjectContext*>::iterator iter = cbegin; iter != cend; ++iter)
    {
        bool ok = findJsonObject(*(*iter), jsonObjectList);
        if (ok)
        {
            // 载入JSON完成后再清除
//             (*iter)->removeFromParent();
//             freeObjectContext(*iter);
//             possibleObjectList.erase(iter--);
        }
    }
    //ObjectContext::dumpObjectContext(parentContext);

#if 0
    // 待所有对象已经创建完毕后，再统一初始化属性，避免属性中使用了对象名而找不到对象 [3/21/2016 CHENHONGHAO]
    for (QList<ObjectContext*>::iterator iter = cbegin; iter != cend; ++iter)
    {
        qDebug() << (*iter)->toString();
        bool ok = parseKeys(*(*iter));
        if (!ok)
        {
            // 已经在各层关键节点输出了足够的错误信息，无需再次报错 [3/21/2016 CHENHONGHAO]
        }
    }
#endif

    // FIXME: 此处只返回数组首个元素的指针，应该改进为返回整个数组？ [4/11/2016 CHENHONGHAO]
    return QVariant::fromValue<QObject*>((*cbegin)->qObject());
}

/*! 
 * 载入文件中的JSON数据
 * @param[in]  jsonFile             JSON文件路径
 * @param[in]  parentContext        该JSON数据的父对象，该JSON中的全部对象将被挂载于父对象下方
 * @param[in]  parentKey            通常需要为该JSON数据指定一个Key，用于标识对象树的主分支
 * @param[in]  possibleObjectList   可能是对象的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @param[in]  jsonObjectList       可能是JSON文件的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @return     加载得到的根对象或根数组
 */
QVariant JsonLoader::load(
    const QString& jsonFile,
    ObjectContext& parentContext, 
    const QString& parentKey,
    QList<ObjectContext*>& possibleObjectList,
    QList<ObjectContext*>& jsonObjectList
    )
{
    QByteArray jsonData = readJsonFile(jsonFile);
    if (jsonData.isNull())
        return QVariant();
    
    return load(jsonData, parentContext, jsonFile, possibleObjectList, jsonObjectList);
}

/*! 
 * 载入内存中的JSON数据（例如来自网络的、代码中的JSON）
 * @param[in]  jsonData         内存中的JSON数据
 * @param[in]  parentKey        通常需要为该JSON数据指定一个Key，用于标识对象树的主分支
 * @param[in]  defaultMetaType  如果JSON对象未指定类型，则使用此默认类型创建对象（仅使用一次）
 * @return     加载得到的根对象或根数组
 */
QVariant JsonLoader::load( const QByteArray& jsonData, const QString& parentKey, int defaultMetaType )
{
    QList<ObjectContext*> possibleObjectList;
    QList<ObjectContext*> jsonObjectList;

    int oldDefaultMetaType = this->defaultMetaType();
    if (defaultMetaType != QMetaType::UnknownType)
        setDefaultMetaType(defaultMetaType);

    // 由于直接指定JSON数据流时，parentKey是用户传入的，有重复的可能，
    // 因此为了保险起见，这里不应使用hash [3/18/2016 CHENHONGHAO]
    QByteArray jsonDataWithoutComment = removeComments(jsonData);

    QVariant loadedVariant = load(
        jsonDataWithoutComment, 
        m_rootObjectContext, 
        parentKey, 
        possibleObjectList, 
        jsonObjectList
        );

    while (!jsonObjectList.isEmpty())
    {
        ObjectContext* currentContext = jsonObjectList.front();
        ObjectContext* parentContext = currentContext->parent();
        QString parentKey = currentContext->parentKey();
        QString childJsonPath = currentContext->value().toString();

        // 直接文件嵌套（数组中直接指定子文件名）时，
        // 需要使用子文件名作为parentKey，否则会引起无限递归 [3/17/2016 CHENHONGHAO]
        if (parentContext)
        {
            QJsonValue& parentValue = parentContext->value();
            QJsonValue::Type parentValueType = parentValue.type();
            // FIXME? 此处的判定条件可能有逻辑漏洞
            if (parentValueType != QJsonValue::Object)
            {
                parentKey = childJsonPath;
            }
        }

        jsonObjectList.pop_front();
        
        // 应注意：引用JSON文件的可能是一个对象的属性，如果彻底移除，
        // 则尽管对象载入成功，属性不会被赋值 [3/16/2016 CHENHONGHAO]
        // 此处应移除，因为load时会在createObjectContextTree的时候
        // 重新将currentContext放入parentContext的parentKey下
        currentContext->removeFromParent();
        
        //freeObjectContext(currentContext);
        // FIXME: 此处有效率问题，可以考虑先置清除标记，最后批量清除对象
        possibleObjectList.removeAll(currentContext);

        QByteArray childJsonData = readJsonFile(childJsonPath);
        if (jsonData.isNull())
            continue;

        QVariant loadedObjects = load(childJsonData, *parentContext, parentKey, possibleObjectList, jsonObjectList);
        if (!loadedObjects.isValid())
        {
            emit error(InvalidRootValue, QString("Failed to load object(s) from ") + childJsonPath);
        }
        else if (loadedObjects.type() != QMetaType::QObjectStar)
        {
            emit error(
                InvalidRootValue, 
                QString("Unsupported data (%1) loaded from %2")
                .arg(loadedObjects.typeName())
                .arg(childJsonPath)
                );
        }
        else
        {
            QObject* loadedObject = loadedObjects.value<QObject*>();
            currentContext->setQObject(loadedObject);
        }
    }

    //ObjectContext::dumpObjectContext(m_rootObjectContext);

#if 1
    // 待所有对象已经创建完毕后，再统一初始化属性，避免属性中使用了对象名而找不到对象 [3/21/2016 CHENHONGHAO]
    // Parse properties in possibleObjectList
    QList<ObjectContext*>::iterator cbegin = possibleObjectList.begin();
    QList<ObjectContext*>::iterator cend = possibleObjectList.end();
    int count = possibleObjectList.size();
    if (m_propertyDependencyMode != ChildrenDependsOnParent)
    {
        // 父对象依赖于子对象，首先加载子对象，从队列尾部开始
        QList<ObjectContext*>::iterator iter = cend;
        while (count--)
        {
            // 对象依赖问题：目前并未解析依赖关系树，仅默认先初始化子对象，后初始化父对象，对于大部分场景足矣 [5/6/2016 CHENHONGHAO]
            parseKeys(*(*--iter));
            // 已经在各层关键节点输出了足够的错误信息，无需再次报错 [3/21/2016 CHENHONGHAO]
        }
    }
    else
    {
        QList<ObjectContext*>::iterator iter = cbegin;
        while (count--)
        {
            parseKeys(*(*iter));
            ++iter;
        }
    }
#endif
    //ObjectContext::dumpObjectContext(m_rootObjectContext);

#if JSON_LOADER_DEBUGGING_LEVEL >= 3
    qDebug() << "================= ObjectContext Tree After Loading" << parentKey << "=================";
    ObjectContext::dumpObjectContext(m_rootObjectContext);
#endif

    setDefaultMetaType(oldDefaultMetaType);

    return loadedVariant;
}

/*! 
 * 载入文件中的JSON数据
 * @param[in]  jsonFile         JSON文件路径
 * @param[in]  defaultMetaType  如果JSON对象未指定类型，则使用此默认类型创建对象（仅使用一次）
 * @return     加载得到的根对象或根数组
 * @note       该JSON文件的根对象将指定默认Key为文件路径
 */
QVariant JsonLoader::load( const QString& jsonFile, int defaultMetaType )
{
    QByteArray jsonData = readJsonFile(jsonFile);
    if (jsonData.isNull())
        return QVariant();

    return load(jsonData, jsonFile, defaultMetaType);
}

/** 
 * 移除已经载入的对象，包括从json文件中载入的（指定filePath）以及从QByteArray载入的（指定parentKey）
 * @param[in]  filePathOrParentKey  文件路径或者JSON中的父节点的key
 * @param[in]  removeChildren       是否移除子对象
 * @return     bool
 */
bool JsonLoader::remove(const QString& filePathOrParentKey, bool removeChildren /*= true*/)
{
    if (filePathOrParentKey.isEmpty() || !removeChildren)
    {
        // 目前不支持也没必要不removeChildren
        return false;
    }

    KeyObjectContextMapConstIter iter = m_rootObjectContext.constChild(filePathOrParentKey);
    if (iter == m_rootObjectContext.constChildEnd())
        return false;
   
    ObjectContextList loadedObjects = iter->second;
    bool allOk = true;
    foreach(ObjectContext* object, loadedObjects)
    {
        if (!object || !object->removeFromParent())
        {
            allOk = false;
        }
    }

    return allOk;
}

/**
 * 添加一个全局对象，使该对象可以被本JsonLoader内部的各个QObject对象所引用，绑定信号/槽等
 * @param[in]    object 全局对象
 * @return       操作成功返回true    
 */    
bool JsonLoader::addGlobalObject(QObject* object)
{
    if (existsInGlobal(object))
        return false;

    ObjectContext* context = allocObjectContext("global", QJsonValue());
    if (context && object)
    {
        context->setQObject(object);
        context->setId(object->objectName());

        KeyObjectContextMapIter iter = m_rootObjectContext.child("global");
        if (m_rootObjectContext.addChild("global", context, iter) != m_rootObjectContext.childEnd())
            return true;
    }
    
    return false;
}

/**
 * 添加一个全局对象，且将其下的Recursively的孩子都添加为全局对象
 */
bool JsonLoader::addGlobalObject(QObject* object, bool allChildren)
{
    if (allChildren)
    {
        QList<QObject *> children = object->findChildren<QObject *>();
        foreach(QObject* child, children)
        {
            addGlobalObject(child);
        }
    }
    return addGlobalObject(object);
}

/*!
 * 判断对象是否已经是全局对象
 */
bool JsonLoader::existsInGlobal(const QObject* obj)
{
    KeyObjectContextMap::iterator iter = m_rootObjectContext.child("global");
    if (iter != m_rootObjectContext.childEnd())
    {
        KeyObjectContextPair pair = *iter;
        ObjectContextList list = pair.second;
        foreach(ObjectContext* oc, list)
        {
            if (oc->id() == obj->objectName()
                && oc->qObject() == obj)
            {
                return true;
            }
        }
    }
    return false;
}

/**
 * 移除已经添加的全局对象
 * @param[in]    object         已经添加的全局对象
 * @param[in]    removeChildren 是否移除子对象，目前不支持不移除
 * @return       操作成功返回true
 */
bool JsonLoader::removeGlobalObject(QObject* object, bool removeChildren)
{
    bool ok = false;

    if (object == NULL || !removeChildren) 
    {
        // 目前不支持也没必要不removeChildren
        return false;
    }

    KeyObjectContextMapConstIter iter = m_rootObjectContext.constChild("global");
    if (iter != m_rootObjectContext.constChildEnd())
    {
        const ObjectContextList& children = iter->second;
        foreach(ObjectContext* o, children)
        {
            if (o->qObject() == object)
            {
                ok = o->removeFromParent();
            }
        }
    }

    return ok;
}

/**
 * 根据对象名称从上到下查找已经加载的对象
 * @param[in]    objectName 对象名称
 * @return       查找结果，未找到则返回NULL
 */
QObject* JsonLoader::findObject(const QString& objectName)
{
    Object* object = m_rootObjectContext.findDownwards(objectName);
    return object ? object->qObject() : NULL;
}

/**
 * 将对象从其父对象的map中移除
 */
bool JsonLoader::removeObject(const QString& name)
{
    ObjectContext* object = static_cast<ObjectContext*>(m_rootObjectContext.findDownwards(name));
    if (NULL == object)
    {
        return false;
    }
    ObjectContext* parent = static_cast<ObjectContext*>(object->parent());
    if (NULL == parent)
    {
        return false;
    }
    return parent->removeChild(object->parentKey());
}

/*!
 * 清除载入过程中使用的临时缓冲区等，释放内存
 * @note 执行本操作需要一定时间，仅用于内存资源受限的设备，并仅应在全部对象已经载入后使用一次
 */
void JsonLoader::cleanup()
{
    // TODO:
    // 移除无parent的孤立ObjectContext
    // 将有parent的ObjectContext的value置空，释放内存
    // 释放JsonFileDataHash
    m_jsonDataBuffer.clear();

    // 是否需要独立拷贝一份Object的精简版？
}

/**
 * 注册一个外部的对象创建器，用于语法扩展
 * @param[in]    creator    对象创建器
 * @return       操作成功返回true
 */
bool JsonLoader::registerObjectCreator( ObjectCreator* creator )
{
    if (creator == NULL)
        return false;

    m_objectCreators.push_back(creator);
    return true;
}

/**
 * 注册一个外部的Key解析器，用于语法扩展
 * @param[in]    parser    Key解析器
 * @return       操作成功返回true
 */
bool JsonLoader::registerKeyParser( KeyParser* parser )
{
    if (parser == NULL)
        return false;

    m_keyParsers.push_back(parser);
    return true;
}

/**
 * 注册一个外部的ArrayValue解析器，用于语法扩展
 * @param[in]    parser    ArrayValue解析器
 * @return       操作成功返回true
 */
bool JsonLoader::registerArrayValueParser( ArrayValueParser* parser )
{
    if (parser == NULL)
        return false;

    m_arrayValueParsers.push_back(parser);
    return true;
}

/**
 * 注册一个外部的StringValue解析器，用于语法扩展
 * @param[in]    parser    StringValue解析器
 * @return       操作成功返回true
 */
bool JsonLoader::registerStringValueParser( StringValueParser* parser )
{
    if (parser == NULL)
        return false;

    m_stringValueParsers.push_back(parser);
    return true;
}

/*! 
 * 分配一个对象上下文，可能使用内存池
 * @param[in]  parentKey    用于初始化该对象上下文的parentKey
 * @param[in]  jsonValue    用于初始化该对象上下文的jsonValue
 * @return     分配得到的对象上下文指针
 */
ObjectContext* JsonLoader::allocObjectContext( const QString& parentKey, const QJsonValue& jsonValue )
{
#if ENABLE_MEM_POOL
    // 使用内存池分配ObjectContext对象
    m_objectContextBuffer.push_back(ObjectContext(parentKey, jsonValue));
    return &m_objectContextBuffer.back();
#else
    return new ObjectContext(parentKey, jsonValue);
#endif
}

/*! 
 * 释放一个对象上下文，可能使用内存池
 * @param[in]  objectContext 分配得到的对象上下文指针
 * @return     操作成功返回true
 */
bool JsonLoader::freeObjectContext( ObjectContext* objectContext )
{
#if ENABLE_MEM_POOL
    Q_ASSERT_X(false, "JsonLoader::freeObjectContext", "DO NOT call freeObjectContext frequently.");
#else
    delete objectContext;
#endif
    return true;
}

/*! 
 * 读取一个JSON文件的全部数据，去除注释并缓存，从而加快多次载入的文件的处理速度
 * @param[in]  jsonFile JSON文件路径
 * @return     载入的JSON数据
 */
QByteArray JsonLoader::readJsonFile( const QString& jsonFile )
{
#if JSON_LOADER_DEBUGGING_LEVEL >= 2
    qDebug() << "Reading JSON file: " << jsonFile;
#endif

    // 使用文件缓冲区加速多次载入同一JSON文件的场景（包含型被动载入）
    QHash<QString, QByteArray>::const_iterator bufferIter = m_jsonDataBuffer.find(jsonFile);
    bool foundInBuffer = bufferIter != m_jsonDataBuffer.constEnd();
    bool multiMapped   = foundInBuffer ? ++bufferIter != m_jsonDataBuffer.constEnd() : false;
    if (foundInBuffer && !multiMapped)
    {
        return (--bufferIter).value();
    }

    QByteArray jsonData;
    QFile file(jsonFile);
    if (file.open(QFile::ReadOnly))
    {
        jsonData = file.readAll();
        file.close();
        if (jsonData.isEmpty()) {
            emit error(InvalidFile, QString("Empty JSON file: ") + jsonFile);
            return jsonData;
        }
    } else {
        QString currentPath = QDir::currentPath();
        emit error(
            InvalidFile, 
            QString("Failed to open JSON file: ") + jsonFile + 
            "\r\n@Path:" + currentPath
            );
        return jsonData;
    }

    QByteArray jsonDataWithoutComment = removeComments(jsonData);
    m_jsonDataBuffer.insert(jsonFile, jsonDataWithoutComment);

#if 0
    QFile debugFile(jsonFile + ".nocomment");
    debugFile.open(QFile::WriteOnly);
    debugFile.write(jsonDataWithoutComment);
    debugFile.close();
#endif

    return jsonDataWithoutComment;
}

/*! 
 * 移除JSON数据中的注释（由于JSON原生语法不支持注释，这里人为引入C-Style注释并在解析前移除）
 * @param[in]  jsonData 含注释的JSON数据
 * @return     不含注释的JSON数据
 */
QByteArray JsonLoader::removeComments( const QByteArray& jsonData ) const
{
    QByteArray result;

    int currentOffset = 0;
    int commentBegin = 0;
    while ((commentBegin = jsonData.indexOf("//", currentOffset)) >= 0)
    {
        int commentEnd = jsonData.indexOf('\n', commentBegin);
        result.append(jsonData.mid(currentOffset, commentBegin - currentOffset));
        currentOffset = commentEnd + 1;
    }

    if (currentOffset == 0) {
        return jsonData;
    }

    result.append(jsonData.mid(currentOffset));
    return result;
}

/*! 
 * 根据指定的JSON数据及其子数据，创建（可能的）对象上下文（ObjectContext）树
 * @param[in]  jsonValue            定的JSON数据
 * @param[in]  parentContext        该JSON数据的父对象，该JSON中的全部对象将被挂载于父对象下方
 * @param[in]  parentKey            通常需要为该JSON数据指定一个Key，用于标识对象树的主分支
 * @param[in]  possibleObjectList   可能是对象的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @return     对象上下文（ObjectContext）树新增节点个数
 */
int JsonLoader::createObjectContextTree( const QJsonValue& jsonValue, ObjectContext& parentContext, const QString& parentKey, QList<ObjectContext*>& possibleObjectList )
{
    int count = 0;
    QStringList unusedKeyTags;

    typedef QPair<QString, QJsonValue> KeyValuePair;
    QQueue< IterInfo > valueQ;
    IterInfo rootInfo;
    rootInfo.key    =  parentKey;
    rootInfo.value  =  jsonValue;
    rootInfo.object = &parentContext;
    valueQ.enqueue(rootInfo);

    while (!valueQ.isEmpty())
    {
        IterInfo info = valueQ.dequeue();
        QString key = info.key;
        parseTags(key, unusedKeyTags);
        //qDebug() << "Info:" << info.key;

        QJsonValue::Type type = info.value.type();
        if (type == QJsonValue::Undefined)
            continue;

        if (type != QJsonValue::Array)
        //if (type == QJsonValue::Object || type == QJsonValue::String)
        {
            ObjectContext *objectContext = allocObjectContext(key, info.value);
            possibleObjectList.push_back(objectContext);
            info.object->addChild(key, objectContext);
            count++;

            if (type == QJsonValue::Object) 
            {
                QJsonObject jsonObject = info.value.toObject();
                QJsonObject::const_iterator iter = jsonObject.constBegin();
                QJsonObject::const_iterator cend = jsonObject.constEnd();
                for (; iter != cend; ++iter) 
                {
                    IterInfo childInfo;
                    childInfo.key = iter.key();
                    childInfo.value = iter.value();
                    childInfo.object = objectContext;
                    valueQ.enqueue(childInfo);
                }
            }

            continue;
        }

        QJsonArray jsonArray = info.value.toArray();
        QJsonArray::const_iterator arrayIter = jsonArray.constBegin();
        QJsonArray::const_iterator cend = jsonArray.constEnd();

        KeyObjectContextMapIter childIter;

        // 在子ObjectContext列表头部放入特殊的数组标识符 [3/18/2016 CHENHONGHAO]
        ObjectContext *arrayObjectContext = allocObjectContext(key, jsonArray);
        childIter = info.object->addChild(key, arrayObjectContext);
        // 然后在列表的尾部依次追加数组的每一个元素 [3/18/2016 CHENHONGHAO]
        for (; arrayIter != cend; ++arrayIter)
        {
            QJsonValue::Type type = (*arrayIter).type();
            if (type == QJsonValue::Undefined)
                continue;

            //if (type == QJsonValue::Object || type == QJsonValue::String || type == QJsonValue::Array)
            ObjectContext *objectContext = allocObjectContext(key, *arrayIter);
            possibleObjectList.push_back(objectContext);
            childIter = info.object->addChild(key, objectContext, childIter);
            count++;

            if (type == QJsonValue::Array)
            {
                // 目前仅通过QVariantList支持纯数据类型的Array-in-array [10/26/2016 CHENHONGHAO]
                //emit error(UnsupportedFeature, "Array-in-array is NOT supported in current version.");
                //                         IterInfo childInfo;
                //                         childInfo.key = QString();
                //                         childInfo.value = *iter;
                //                         childInfo.object = info.object;
                //                         valueQ.enqueue(childInfo);
                //                         continue;
            }
            else if (type == QJsonValue::Object)
            {
                QJsonObject jsonObject = (*arrayIter).toObject();
                QJsonObject::const_iterator objIter = jsonObject.constBegin();
                QJsonObject::const_iterator objCend = jsonObject.constEnd();
                for (; objIter != objCend; ++objIter) 
                {
                    IterInfo childInfo;
                    childInfo.key = objIter.key();
                    childInfo.value = objIter.value();
                    childInfo.object = objectContext;
                    valueQ.enqueue(childInfo);
                }
            }
        }
    }

    return count;
}

/*! 
 * 为指定的对象上下文创建QObject对象
 * @param[in]  objectContext 指定的对象上下文
 * @return     bool
 */
bool JsonLoader::createQObject( ObjectContext& objectContext )
{
    bool ok = false;

    foreach (ObjectCreator* creator, m_objectCreators)
    {
        if (creator->parse(&objectContext))
        {
            ok = true;
            break;
        }
    }

    if (!ok)
    {
        ParentPropertyObjectCreator parentPropertyObjectCreator(this);
        ok = parentPropertyObjectCreator.parse(&objectContext);
    }

    if (!ok)
    {
        // 此处使用默认类型创建对象，方便顶层载入数组等场景（此时不用给每一个元素指定metaType了） [5/6/2016 CHENHONGHAO]
        // 需要注意此处不支持legacy keyword: id
        DefaultTypeObjectCreator defaultTypeObjectCreator(this, m_defaultMetaType);
        ok = defaultTypeObjectCreator.parse(&objectContext);
    }

#if 0
    // ObjectCreator需要处理QString等非QObject子类对象的场景，在这些场景下，不需要提前创建对象
    if (ok && objectContext.qObject() == NULL)
    {
        emit error(ObjectCreatorError, "One of the Object-Creators returned true but didn't create an object");
        ok = false;
    }
#endif

    return ok;
}

/*! 
 * 查找指定的对象上下文中可能嵌套的JSON文件
 * @param[in]  objectContext  指定的对象上下文
 * @param[in]  jsonObjectList 可能是JSON文件的对象上下文（ObjectContext）列表，追加模式，原内容不清空
 * @return     指定的对象上下文确实嵌套了JSON文件则返回true
 */
bool JsonLoader::findJsonObject( ObjectContext& objectContext, QList<ObjectContext*>& jsonObjectList )
{
    QJsonValue& value = objectContext.value();
    if (value.type() == QJsonValue::String)
    {
        QString string = value.toString();
        if (
            // 现在支持自定义扩展名的文件包含了，只需要在路径头部添加`json`这个tag [12/30/2016 CHENHONGHAO]
            string.endsWith(QLatin1String(".json")) || string.startsWith(QLatin1String("`json`"))
            // 大部分场景不会出现xxx.json的字符串，即使出现，也只是导致误载入，
            // 但此处判断需要大量遍历，效率较低，因此删除
            // 需要注意的是，即使需要严格判断，仅有parentProperty的筛选也是不够的 [5/9/2016 CHENHONGHAO]
            //&& objectContext.parentPropertyType() != QMetaType::QString
            )
        {
            // 使用.ref关键字引用的JSON文件，已经在此之前被嵌套调用加载了，无需添加到队列 [6/15/2016 CHENHONGHAO]
            if (objectContext.parentKey() != QLatin1String(".ref"))
            {
                jsonObjectList.push_back(&objectContext);
                return true;
            }
        }
    }

    return false;
}

/*! 
 * 解析指定的对象上下文的一个JSON Key
 * @param[in]  objectContext 指定的对象上下文
 * @param[in]  iter          指定的对象上下文的Key迭代器（的当前值）
 * @return     操作成功返回true
 */
bool JsonLoader::parseKey( ObjectContext& objectContext, KeyObjectContextMapConstIter iter )
{
    bool parsed = false;
    const QString& key = iter->first;
    // 部分提前处理过的key（例如.type）会被处理者设置为空（为了保证效率，不移除），
    // 这里不需要再处理 [5/9/2016 CHENHONGHAO]
    if (key.isEmpty())
        return true;

#if defined(_DEBUG) && 0
    //qDebug() << key;
    // 此处专用于调试下断点 [3/16/2016 CHENHONGHAO]
    if (key == "bool2")
    {
        int breakpoint = 0;
    }
#endif

    foreach (KeyParser* keyParser, m_keyParsers)
    {
        if (!keyParser->matches(key)) {
            continue;
        }

        if (keyParser->parse(&objectContext, iter)) 
        {
            parsed = true;
            break;
        }
    }

    if (!parsed) 
    {
        QString jsonValueStr;
        if (!iter->second.isEmpty())
            jsonValueStr = iter->second.front()->value().toString();
        emit error(
            KeyParserError, 
            QString("Failed to parse [\"%1\":\"%2\"] for %3")
            .arg(key)
            .arg(jsonValueStr)
            .arg(objectContext.toString())
            );

        // 以后可能还会在其他地方引用到此对象 [3/17/2016 CHENHONGHAO]
        //objectContext.removeChild(iter);
    }

    return parsed;
}

/*! 
 * 解析指定的对象上下文的全部JSON Key
 * @param[in]  objectContext 指定的对象上下文
 * @return     全部操作成功返回true
 */
bool JsonLoader::parseKeys( ObjectContext& objectContext )
{
    KeyObjectContextMapConstIter iter = objectContext.constChildBegin();
    KeyObjectContextMapConstIter cend = objectContext.constChildEnd();
    bool allParsed = true;

    for (iter; iter != cend; ++iter)
    {
        if (!parseKey(objectContext, iter)) {
            allParsed = false;
        }
    }

    return allParsed;
}

/*! 
 * 解析Key或者Value中的tags
 * @param[inout] string JSON中的原始字符串，以及裁减后的字符串输出
 * @param[in]    tags   解析得到的tags
 * @return       解析得到的tag个数
 */
int JsonLoader::parseTags(QString& valueString, QStringList& tags) const
{
    bool ok = true;

    // 分割所有tags，从右向左解析
    QString pureValueString = valueString;
    int length = valueString.length();
    int offset = length - 1;
    while (offset >= 0)
    {
        int startIndex = -1;
        int endIndex   = -1;

        endIndex = valueString.lastIndexOf(QLatin1Char('`'), offset);
        if (endIndex > 0) {
            startIndex = valueString.lastIndexOf(QLatin1Char('`'), endIndex - 1);
        } 
        else if (endIndex == 0) 
        {
            ok = false;
            break;
        }
        if (startIndex < 0 || endIndex < 0)
        {
            // 已经解析完所有tag
            break;
        }

        QString tag = valueString.mid(startIndex + 1, endIndex - startIndex - 1);
        if (tag.length() > 0)
        {
            tags.push_back(tag);
            pureValueString.remove(startIndex, endIndex - startIndex + 1);
        }

        offset = startIndex - 1;
    }

    // 输出移除tags的纯字符串
    valueString = pureValueString;

    return ok ? tags.size() : -1;
}

/*! 
 * 解析指定的对象上下文的一个JSON Value
 * @param[in]  objectContext 指定的对象上下文
 * @param[in]  metaTypeHint  Value的元数据类型的提示
 * @return     该JSON Value解析得到的QVariant对象
 */
QVariant JsonLoader::parseValue( ObjectContext& objectContext, int metaTypeHint )
{
    QVariant result;

    QJsonValue& jsonValue = objectContext.value();
    QJsonValue::Type jsonType = jsonValue.type();
#if 0
    // 数组拆分得到的子ObjectContext列表的头部为完整数组本身，需要排除此情况才能启用此断言 [3/18/2016 CHENHONGHAO]
    Q_ASSERT_X(
        jsonType != QJsonValue::Array, 
        "JsonLoader::parseValue", 
        "JsonArray should have been splitted into single ObjectContexts already."
        );
#else
    // 这种情况下，只支持一个场景：多维纯数据的数组（QVariantList），也就是说不准备支持对象列表未展开的情况 [10/26/2016 CHENHONGHAO]
    if (jsonType == QJsonValue::Array)
    {
        qDebug() << "Nested JSON array value can only be parsed as QVariantList.";
        return jsonValue.toVariant();
    }
#endif

    // FIXME? 如果值本身的对象存在，则目前所有语法均说明key是一个对象类型 [3/16/2016 CHENHONGHAO]
    if (jsonType == QJsonValue::Object || objectContext.qObject())
    {
        return QVariant::fromValue<QObject*>(objectContext.qObject());
    }
    else if (jsonType == QJsonValue::Null)
    {
        return QVariant::fromValue<QObject*>(NULL);
    }

    QVariant variantValue = jsonValue.toVariant();
    int variantValueType = variantValue.type();
    if (metaTypeHint == QMetaType::UnknownType)
        metaTypeHint = m_defaultMetaType;
    if (metaTypeHint != QMetaType::UnknownType && variantValueType!= metaTypeHint)
    {
        int     possibleMetaType = QMetaType::UnknownType;

        if (variantValueType == QMetaType::QString)
        {
            // QVariant.cpp, Line 287: 以下代码完成QString->bool，判定逻辑太过简单，因此需要特殊处理
            // return !(str == LiteralWrapper("0") || str == LiteralWrapper("false") || str.isEmpty());
            if (metaTypeHint == QMetaType::Bool)
            {
                QString possibleBoolString = variantValue.toString().toLower();
                if (possibleBoolString == QLatin1String("true")) {
                    return true;
                } else if (possibleBoolString == QLatin1String("false")) {
                    return false;
                } else {
                    // 尝试先转换为int，能成功则认为确实是Bool
                    possibleMetaType = QMetaType::Int;
                }
            }
            // QVariant.cpp, Line 186: 以下代码完成QString->int，判定逻辑只支持十进制，因此需要特殊处理
            else if (metaTypeHint == QMetaType::Char || metaTypeHint == QMetaType::UChar ||
                metaTypeHint == QMetaType::Short || metaTypeHint == QMetaType::UShort ||
                metaTypeHint == QMetaType::Int || metaTypeHint == QMetaType::UInt)
            {
                QString string = variantValue.toString();
                bool ok = false;
                uint number = string.toUInt(&ok, 0);
                if (ok) 
                {
                    QVariant result(number);
                    result.convert(metaTypeHint);
                    return result;
                }
            }
        }

        result = variantValue;
        int targetMetaType = possibleMetaType != QMetaType::UnknownType ? possibleMetaType : metaTypeHint;
        if (targetMetaType == QMetaType::QVariant || result.convert(targetMetaType)) 
        {
            QString text = variantValue.toString();
            QStringList tags;
            // 如果属性类型是QVariant，而实际上通过object这个tag指定了一个对象，
            // 则不应该直接返回 [9/23/2016 CHENHONGHAO]
            if (variantValue.type() != QMetaType::QString ||
                !(parseTags(text, tags) > 0))
                return result;
        }
    }

    if (jsonType != QJsonValue::String)
    {
        // Bool/Double，可能转换不会成功，
        // 交给Parser做最后尝试，也许可以成功，因为有可能只是metaTypeHint有问题
        return variantValue;
    }

    
    bool parsed = false;
    QString string = jsonValue.toString();
    QStringList tags;
    if (parseTags(string, tags) < 0)
    {
        emit error(
            StringValueParserError,
            "Failed to parse string tags for: " + string
            );
    }

    // 当且仅当没有自定义tag时，说明可能是一些常见的基础数据类型，优先使用QVariant内置转换 [12/27/2016 CHENHONGHAO]
    if (tags.isEmpty())
    {
        // 尝试使用QVariant对QString进行标准转换，例如字体、时间等
        result = string;

        if (metaTypeHint != QMetaType::UnknownType &&
            metaTypeHint != QMetaType::QString)
        {
            if (metaTypeHint == QMetaType::QVariant)
            {
                // 如果目标类型原本就是一个QVariant，那么这里是不需要转换的 [6/3/2016 CHENHONGHAO]
                parsed = true;
            }
            else if (metaTypeHint == QMetaType::QRegExp)
            {
                // 增加从脚本中载入QRegExp的能力 [8/6/2016 CHENHONGHAO]
                result = QVariant(QRegExp(string));
                parsed = true;
            }
            else if (result.convert(metaTypeHint)) {
                parsed = true;
            }
        }
    }

    // 首先尝试根据metaType快速定位一些合适的parsers
    if (!parsed && metaTypeHint != QMetaType::UnknownType)
    {
        foreach(StringValueParser* stringValueParser, m_stringValueParsers)
        {
            if (stringValueParser && 
                stringValueParser->metaType() == metaTypeHint && 
                stringValueParser->matches(metaTypeHint, tags))
            {
                result = stringValueParser->parse(&objectContext, string, tags);
                if (result.isValid())
                {
                    parsed = true;
                    break;
                }
            }
        }
    }

    // 如果尚未解析成功，则尝试遍历所有parsers（顺序不能保证），直至解析成功
    if (!parsed)
    {
        foreach (StringValueParser* stringValueParser, m_stringValueParsers)
        {
            if (stringValueParser && stringValueParser->matches(metaTypeHint, tags))
            {
                result = stringValueParser->parse(&objectContext, string, tags);
                if (result.isValid())
                {
                    parsed = true;
                    break;
                }
            }
        }
    }

    if (!parsed)
    {
        emit error(
            StringValueParserError, 
            QString("Failed to parse String value: %1 with metaTypeHint:%2(%3)")
            .arg(string)
            .arg(GET_METATYPE_NAME_METHOD(metaTypeHint))
            .arg(metaTypeHint)
            );
    }

    return result;
}

/*! 
 * 解析一个JSON Value Array的数组元素类型，通常根据Key Property的类型来unwind得到元素类型
 * @param[in]  propertyMetaTypeId  （属性）数组本身的metaType
 * @param[in]  propertyMetaTypeName 属性类型名称
 * @return     数组元素的metaType
 */
int JsonLoader::parseArrayElementType( int propertyMetaTypeId, const QString& propertyMetaTypeName )
{
    foreach (ArrayValueParser* arrayValueParser, m_arrayValueParsers)
    {
        int result = arrayValueParser->parseArrayElementType(propertyMetaTypeId, propertyMetaTypeName);
        if (result != QMetaType::UnknownType)
        {
            return result;
        }
    }

    return QMetaType::UnknownType;
}

/*! 
 * 解析一个JSON Value Array
 * @param[in]  valueArray   Value Array
 * @param[in]  metaTypeHint Value Array的元数据类型的提示
 * @return     该JSON Value Array解析得到的QVariant对象
 */
QVariant JsonLoader::parseArrayValue( const QVariantList& valueArray, int metaTypeHint )
{
    QVariant result;
    bool parsed = false;
    if (metaTypeHint == QMetaType::UnknownType)
        metaTypeHint = m_defaultMetaType;
    // 首先尝试根据metaType快速定位一些最合适的parsers
    if (metaTypeHint != QMetaType::UnknownType)
    {
        foreach(ArrayValueParser* arrayValueParser, m_arrayValueParsers)
        {
            if (arrayValueParser && arrayValueParser->metaType() == metaTypeHint) 
            {
                result = arrayValueParser->parseValue(valueArray);
                if (result.isValid())
                {
                    parsed = true;
                    break;
                }
            }
        }
    }

    // 如果尚未解析成功，则尝试遍历所有parsers（顺序不能保证），直至解析成功
    if (!parsed)
    {
        foreach (ArrayValueParser* arrayValueParser, m_arrayValueParsers)
        {
            if (arrayValueParser->matches(metaTypeHint)) 
            {
                result = arrayValueParser->parseValue(valueArray);
                if (result.isValid())
                {
                    parsed = true;
                    break;
                }
            }
        }
    }

    if (!parsed)
    {
        emit error(
            ArrayValueParserError, 
            QString("Failed to parse array value with metaTypeHint:%1").arg(metaTypeHint)
            );
    }

    return result;
}

#if JSON_LOADER_DEBUGGING_LEVEL >= 1
/*! 
 * JsonLoader错误的默认处理槽函数，输出错误打印信息，可通过宏配置禁用该功能
 * @param[in]  code     错误码
 * @param[in]  message  错误消息
 */
void JsonLoader::reportError( int code, const QString& message ) const
{
    //qCritical() << "JSON error [" << code <<"]: " << qUtf8Printable(message);
    qCritical() << "JSON error [" << code << "]: " << message.toUtf8().constData();
}
#endif

QString JsonLoader::dumpJsonData(const QByteArray& data, int offset) const
{
    int length = data.length();
    int prevLineCount = 0;
    int nextLineCount = 0;
    int dumpStart = offset;
    int dumpEnd   = offset;

    while (dumpStart >= 0 && prevLineCount < 3)
    {
        int lineStart = data.lastIndexOf('\n', dumpStart-1);
        if (lineStart < 0)
            break;

        dumpStart = lineStart;
        prevLineCount++;
    }
    if (dumpStart < 0) dumpStart = 0;

    while (dumpEnd >= 0 && nextLineCount < 3)
    {
        int lineEnd = data.indexOf('\n', dumpEnd+1);
        if (lineEnd < 0)
            break;

        dumpEnd = lineEnd;
        nextLineCount++;
    }
    if (dumpEnd   < 0) dumpEnd   = length;

    QByteArray dumpData = data.mid(dumpStart+1, dumpEnd-dumpStart-1);
    dumpData.insert(qMax(offset - dumpStart - 1, 0), '^'); // 错误标记^

    return QString::fromUtf8(dumpData);
}


/*! 
 * 添加指定的对象上下文对应的一条翻译信息（一一对应）
 * @param[in]  objectContext 指定的对象上下文
 * @return     操作成功返回true
 */
bool JsonLoader::addTranslation( ObjectContext& objectContext )
{
    m_translations.insert(&objectContext);
    return true;
}

/*! 
 * 移除指定的对象上下文对应的一条翻译信息（一一对应）
 * @param[in]  objectContext 指定的对象上下文
 * @return     操作成功返回true
 */
bool JsonLoader::removeTranslation( ObjectContext& objectContext )
{
    int count = m_translations.remove(&objectContext);
    return count > 0;
}

/*! 
 * 添加指定的对象引用信息
 * @param[in]  objectRef 指定的对象引用信息
 * @return     操作成功返回true
 */
bool JsonLoader::addObjectRef(const ObjectRef& objectRef)
{
    m_objectRefs.push_back(objectRef);
    return true;
}

/*! 
 * 移除指定的对象引用信息
 * @param[in]  objectRef 指定的对象引用信息
 * @return     操作成功返回true
 */
bool JsonLoader::removeObjectRef(const ObjectRef& objectRef)
{
    return m_objectRefs.removeAll(objectRef) > 0;
}

/** 
 * 获取当前已经添加的全部对象引用信息
 * @return     QList<ObjectRef> 当前已经添加的全部对象引用信息
 */
QList<ObjectRef> JsonLoader::objectRefs()
{
    return m_objectRefs;
}

/**
* 清除当前已经添加的全部对象引用信息
*/
void JsonLoader::clearObjectRefs()
{
    m_objectRefs.clear();
}

/**
 * 翻译/重新翻译全部的可翻译字符串（中文字符串或标记了`tr`的强制翻译的特殊字符串）
 * @return      成功翻译的字符串个数
 */
int JsonLoader::translateAllStrings()
{
    int count = 0;

    QSet<ObjectContext*>::const_iterator iter = m_translations.constBegin();
    QSet<ObjectContext*>::const_iterator cend = m_translations.constEnd();
    for (iter; iter != cend; ++iter)
    {
        ObjectContext* translation = *iter;
        if (translation == NULL)
            continue;

        ObjectContext* parent = translation->parent();
        if (parent)
        {
            QString parentKey = translation->parentKey();
            KeyObjectContextMapConstIter keyIter = parent->constChild(parentKey);
            if (!parseKey(*parent, keyIter))
            {
                emit error(
                    TranslationError, 
                    QString("Failed to translate string: %1")
                    .arg(translation->toString())
                    );
                continue;
            }

            count++;
        }
    }

    return count;
}

#if ENABLE_TS_FILE
/*! 
 * 将当前JsonLoader已经载入的可翻译字符串保存至QT语言家的ts文件，用于人工翻译
 * @param[in]  tsFile 保存文件路径，若文件已存在，将覆盖该文件，目前不支持文件合并
 * @return     操作成功返回true
 */
bool JsonLoader::createTranslationFile( const QString& tsFile ) const
{
    QFile file(tsFile);
    if (!file.open(QFile::WriteOnly)) {
        return false;
    }

    QTextStream ts(&file);
    ts.setCodec("UTF-8");

    ts << "<?xml version=\"1.0\" encoding=\"utf-8\"?>" << endl;
    ts << "<!DOCTYPE TS>" << endl;
    ts << "<TS version=\"2.1\" language=\"en_US\">" << endl;

    ts << "<context>" << endl;
    ts << "    <name>JsonLoader</name>" << endl;

    foreach (ObjectContext* translation, m_translations)
    {
        if (translation == NULL)
            continue;

        QJsonValue& value = translation->value();
        QString source = value.toString();

        QStringList tags;
        parseTags(source, tags);

        // FIXME: 增加location属性，方便翻译编辑
        ts << "    <message>" << endl;
        ts << "        <source>" << source << "</source>" << endl;
        ts << "    </message>" << endl;
    }

    ts << "</context>" << endl;
    ts << "</TS>" << endl;

    file.close();
    return true;
}
#endif
/*********************************************************************************************************
** End of file
*********************************************************************************************************/
