/****************************************Copyright (c)****************************************************
**
**                                       D.H. InfoTech
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  Object.h
** Latest Version:             V1.0.0
** Latest modified Date:       2016/3/2
** Modified by:                
** Descriptions:               
**
**--------------------------------------------------------------------------------------------------------
** Created by:                 Chen Honghao
** Created date:               2016/3/1
** Descriptions:               Object class  [Generated by VP-UML, IGT1.0]
** 
*********************************************************************************************************/
#ifndef __OBJECT_H__
#define __OBJECT_H__

#include <QObject>
#include <QHash>
#include <QJsonValue>
#include <QMetaObject>
#include <QMetaProperty>
#include <QMetaMethod>

class Object;
class ObjectContext;

#include "JsonLoader_p.h"

class JSON_LOADER_EXPORT Object
{
public:
    /**
     * Constructor
     */
    Object();

public: 
    /**
     * 向上查找指定的对象
     * @param[in]    objectName 对象名称
     * @return       查找到的对象指针，未找到则返回NULL
     */
    virtual Object* findUpwards(const QString& objectName) const;

    /**
     * 向下查找指定的对象
     * @param[in]    objectName 对象名称
     * @return       查找到的对象指针，未找到则返回NULL
     */
    virtual Object* findDownwards(const QString& objectName) const;

    /**
     * 添加一个子对象
     * @param[in]    object 子对象
     * @return       操作成功返回true
     */
    bool addChild(Object* object);

    /**
     * 移除一个子对象
     * @param[in]    object 子对象
     * @return       操作成功返回true
     */
    bool removeChild(Object* object);

    /**
     * 获取指定位置的子对象
     * @param[in]    index 子对象序号
     * @return       查找到的对象指针，未找到则返回NULL
     */
    Object* childAt(int index);

    /**
     * 设置对象对应的QObject对象
     * @param[in]    qobject QObject对象
     */
    void setQObject(QObject* qobject);

    /**
     * 获取对象对应的QObject对象
     * @return    QObject对象
     */
    virtual QObject* qObject() const;

    /**
     * 设置对象的id
     * @param[in]    id 对象id
     */
    bool setId(QString id);

    /**
     * 获取对象的id
     * @return    对象id
     */
    QString id() const;

    /**
     * 设置对象的父对象
     * @param[in]    parent 父对象
     */
    bool setParent(Object* parent);

    /**
     * 获取对象的父对象
     * @return    父对象
     */
    Object* parent() const;

    /**
     * 获取对象的全部子对象
     * @return    全部子对象
     */
    QList<Object*> children() const;

protected: 
    QObject*        m_qobject;              //!< 对应的QObject对象
    Object*         m_parent;               //!< 父对象
    QString         m_id;                   //!< 对象名称（id）
    QList<Object*>  m_children;             //!< 全部子对象
};

class ObjectContext;
typedef QList<ObjectContext*> ObjectContextList;
//typedef QHash<QString, ObjectContextList> KeyObjectContextMap;

class JSON_LOADER_EXPORT KeyObjectContextPair : public QPair<QString, ObjectContextList>
{
public:
    KeyObjectContextPair() : QPair<QString, ObjectContextList>() 
    {
    }
    KeyObjectContextPair(const QString& _first, const ObjectContextList& _second) 
        : QPair<QString, ObjectContextList>(_first, _second)
    {
    }

    bool operator == (const KeyObjectContextPair& other) const
    {
        return this->first == other.first;
    }
};

typedef QList< KeyObjectContextPair > KeyObjectContextMap;
typedef QList< KeyObjectContextPair >::iterator KeyObjectContextMapIter;
typedef QList< KeyObjectContextPair >::const_iterator KeyObjectContextMapConstIter;

class JSON_LOADER_EXPORT ObjectContext : public Object
{
public:
    ObjectContext();
    ObjectContext(const QString& parentKey, const QJsonValue& jsonValue);

    /** 
     * 默认当前对象上下文的父Object也是一个对象上下文，并直接返回父对象上下文的指针
     * @return     ObjectContext*
     */
    ObjectContext* parent()
    {
        return static_cast<ObjectContext*>(m_parent);
    }

    QString& parentKey()
    {
        return m_parentKey;
    }

    QJsonValue& value()
    {
        return m_value;
    }

    KeyObjectContextMapIter child(const QString& key);
    KeyObjectContextMapConstIter constChild(const QString& key);

    KeyObjectContextMapConstIter constChildBegin()
    {
        return m_keyObjectContextMap.cbegin();
    }

    KeyObjectContextMapConstIter constChildEnd()
    {
        return m_keyObjectContextMap.cend();
    }

    KeyObjectContextMapIter childBegin()
    {
        return m_keyObjectContextMap.begin();
    }

    KeyObjectContextMapIter childEnd()
    {
        return m_keyObjectContextMap.end();
    }

    KeyObjectContextMapIter addChild(
        const QString& key, 
        ObjectContext* child, 
        KeyObjectContextMapIter iter
        );

    KeyObjectContextMapIter addChild(const QString& key, ObjectContext* child)
    {
        return addChild(key, child, m_keyObjectContextMap.end());
    }

    bool removeChild(KeyObjectContextMapConstIter iter)
    {
        return removeChild(iter->first, NULL);
        return true;
    }

    bool removeChild(KeyObjectContextMapIter iter)
    {
        m_keyObjectContextMap.erase(iter);
        return true;
    }

    bool removeChild(const QString& key, ObjectContext* child);

    /**
     * 删除map中对应的key,且将m_children对应的孩子删除
     */
    bool removeChild(const QString& key);

    KeyObjectContextMapConstIter findInParent()
    {
        if (!m_parent) {
            return KeyObjectContextMapConstIter();
        }

        return parent()->constChild(m_parentKey);
    }

    bool removeFromParent()
    {
        if (!m_parent) {
            return false;
        }
        return parent()->removeChild(m_parentKey, this);
    }

    
    QMetaProperty property(const QString& key) const;
    static int propertyType(const QMetaProperty& property);

    QMetaProperty parentProperty() const;

    int parentPropertyType() const;


    QList<QMetaMethod> methods(const QString& key) const;
public:
    QString toString() const;
    static void dumpObjectContext(const ObjectContext& context, bool recursively = true);

protected:
    QString             m_parentKey;
    QJsonValue          m_value;
    KeyObjectContextMap m_keyObjectContextMap;
};
Q_DECLARE_METATYPE(ObjectContext)

class JsonFileObjectContext : public ObjectContext
{

};

class LazyLoadObjectContext: public ObjectContext
{
public:
    LazyLoadObjectContext();

    bool isLazyLoadObjectContext() const;

    QObject* qObject() const;

protected:
    const int m_magic;
};

struct ObjectRef
{
public:
    QObject* object;
    QObject* sourceObject;
    QString  name;
    QString  sourceName;
    QStringList overridedProperties;

    bool operator == (const ObjectRef& b) const
    {
        return (object != NULL && object == b.object) || 
            (!name.isEmpty() && name == b.name);
    }

    ObjectRef(
        QObject* _object = NULL,
        QObject* _sourceObject = NULL,
        const QString& _name = QString(),
        const QString& _sourceName = QString()
        )
        : object(_object), sourceObject(_sourceObject), name(_name), sourceName(_sourceName)
    {

    }
};

class JSON_LOADER_EXPORT PropertyBinding : public QObject
{
    Q_OBJECT

public:
    PropertyBinding(
        QObject* observerable, const QMetaProperty& subjectProperty,
        QObject* observer, const QMetaProperty& observerProperty,
        bool notifyOnBind = true // 在刚刚绑定时是否无论属性发生变更均自动notify一次
        );

    ~PropertyBinding();

    operator bool() const
    {
        return isBound();
    }

    bool isBound() const
    {
        return m_bound;
    }

public:
    static PropertyBinding* bind(
        QObject* subject, const QString& subjectProperty,
        QObject* observer, const QString& observerProperty
        );

    static bool fullBind(
        QObject* obj1, const QString& property1,
        QObject* obj2, const QString& property2);

    static bool unbind(PropertyBinding* binding);

protected:
    Q_SLOT void onNotify() const;

protected:
    QObject* m_observable;
    QObject* m_observer;
    QMetaProperty m_observerableProperty;
    QMetaProperty m_observerProperty;
    bool m_bound;
};

class PropertyContext
{
public:
    PropertyContext()
        : m_qObject(NULL)
        , m_fullBind(false)
    {

    }

    QObject* qObject() const
    {
        return m_qObject;
    }

    void setQObject(QObject* qObject)
    {
        m_qObject = qObject;
    }

    QMetaProperty metaProperty() const
    {
        return m_metaProperty;
    }

    void setMetaProperty(const QMetaProperty& metaProperty)
    {
        m_metaProperty = metaProperty;
    }

    bool fullBind() const
    {
        return m_fullBind;
    }

    void setFullBind(bool value)
    {
        m_fullBind = value;
    }

    PropertyBinding* addObserver(QObject* observer,     const QMetaProperty& observerProperty);

    QVariant read() const;
    bool write(const QVariant& value);

protected:
    QObject*        m_qObject;
    QMetaProperty   m_metaProperty;
    bool            m_fullBind;
};
Q_DECLARE_METATYPE(PropertyContext)

class MethodConnection
{
public:
    /*! 
     * 自动绑定两个信号间的模糊信号-槽函数
     * @param[in]  objectA  对象A
     * @param[in]  methodsA 模糊信号/槽A
     * @param[in]  objectB  对象B
     * @param[in]  methodsB 模糊信号/槽B
     * @return     成功绑定的信号-槽对的个数
     */
    static int connect(
        QObject* objectA, const QList<QMetaMethod>& methodsA,
        QObject* objectB, const QList<QMetaMethod>& methodsB
        );

protected:
    static bool matchSignature(const QByteArray& signatureA, const QByteArray& signatureB);
};

class MethodContext
{
public:
    MethodContext() : m_qObject(NULL)
    {

    }

    QObject* qObject() const
    {
        return m_qObject;
    }

    void setQObject(QObject* qObject)
    {
        m_qObject = qObject;
    }

    QList<QMetaMethod> metaMethods() const
    {
        return m_metaMethods;
    }

    void setMetaMethods(const QList<QMetaMethod>& metaMethods)
    {
        m_metaMethods = metaMethods;
    }

protected:
    QObject*           m_qObject;
    QList<QMetaMethod> m_metaMethods;
};
Q_DECLARE_METATYPE(MethodContext)

/**
 *  @class ObjectFactory
 *  @brief 对象工厂，注意由于metaObject()的限制，此工厂通常只用来生产QObject的子类对象
 */
class ObjectFactory
{
public:
    ObjectFactory(const QString& typeName, const QMetaObject* metaObject = NULL) 
        : m_typeName(typeName)
        , m_metaObject(metaObject)
    {

    }

    QString typeName() const
    {
        return m_typeName;
    }

    const QMetaObject* metaObject() const
    {
        return m_metaObject;
    }

    virtual void* create() const = 0;
    virtual void destroy(void* ptr) = 0;

private:
    QString m_typeName;
    const QMetaObject* m_metaObject;
};

template <typename T>
class ObjectFactoryImpl : public ObjectFactory
{
public:
    ObjectFactoryImpl(const QString& typeName, const QMetaObject* metaObject = NULL) 
        : ObjectFactory(typeName, metaObject)
    {
    }

    void* create() const Q_DECL_OVERRIDE
    {
        return new T;
    }

    void destroy(void* ptr) Q_DECL_OVERRIDE
    {
        delete ((T*)ptr);
    }
};

class JSON_LOADER_EXPORT ObjectType
{
public:
    enum 
    {
        ObjectTypeIdBase = 8192
    };

    static void* create(int objectType);
    static void* create(int objectType, void* copy);
    static QObject* clone(const QObject* object);
    static void  destroy(int objectType, void* ptr);

    static int type(const QString& typeName);
    static QString typeName(int objectType);

    static const QMetaObject* metaObjectForType(int objectType);

    
    /*! 
     * 注册一个简单对象（不适用QMetaObject的对象，例如QFont、QDateTime以及自定义类）
     * @param[in]  typeName 类型名称
     * @return     int      类型id
     */
    template <typename T>
    static int registerSimpleObjectType(const QString& typeName)
    {
        return registerFactory(typeName, new ObjectFactoryImpl<T>(typeName));
    }

    /*! 
     * 注册一个QObject子类对象（适用于QMetaObject的对象）
     * @param[in]  typeName 类型名称
     * @return     int      类型id
     */
    template <class T>
    static int registerMetaObjectType(const QString& typeName)
    {
        const QMetaObject& metaObject = T::staticMetaObject;
        return registerFactory(typeName, new ObjectFactoryImpl<T>(typeName, &metaObject));
    }

protected:
    static int registerFactory(const QString& typeName, ObjectFactory* factory);
    static ObjectFactory* factory(int objectType);

private:
    static QHash<QString, int>     s_nameIdMap;
    static QVector<ObjectFactory*> s_factories;
    static int                     s_currentTypeId;
};

#endif
/*********************************************************************************************************
** End of file
*********************************************************************************************************/