/****************************************Copyright (c)****************************************************
**
**                             INNO Instrument(China) Co.Ltd.
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  ActivityManager.cpp
** Latest Version:             V1.0.0
** Latest modified Date:
** Modified by:
** Descriptions:
**
**--------------------------------------------------------------------------------------------------------
** Created by:
** Created date:               2017/5/4
** Descriptions:               ActivityManager class  [Generated by VP-UML, IGT1.2]
**
*********************************************************************************************************/
#include "ActivityManager.h"

ActivityManager* ActivityManager::s_instance = NULL;
ActivityManager::ActivityManager()
{
    m_curActivity = NULL;
    m_model = new ObjectListModel;
    m_activities.clear();
    s_instance = this;
}


ActivityManager::~ActivityManager()
{
    if (m_model)
    {
        delete m_model;
        m_model = NULL;
    }
}

ActivityManager* ActivityManager::instance()
{
    if (!s_instance)
    {
        s_instance = new ActivityManager();
    }
    return s_instance;
}

bool ActivityManager::start(const QString &activityName)
{
    //TODO
    Activity* temp = activity(activityName);
    if (!temp)
    {
        return false;
    }
    m_curActivity = temp;
    return temp->start();
}

bool ActivityManager::start(int index)
{
    //TODO
    m_curActivity = activity(index);
    if (!m_curActivity)
    {
        return false;
    }
    bool ok = m_curActivity->start();
    emit activityStarted(m_curActivity);
    return ok;
}

bool ActivityManager::stop(const QString &activityName)
{
    if (!m_curActivity)
    {
        return false;
    }
    bool ok = m_curActivity->stop();

    m_curActivity = NULL;

    emit activityStoped();
    return ok;
}

bool ActivityManager::stop(int index)
{
    //TODO
    if (!m_curActivity)
    {
        return false;
    }
    bool ok = m_curActivity->stop();

    m_curActivity = NULL;

    emit activityStoped();
    return ok;
}

bool ActivityManager::stop()
{
    if (!m_curActivity)
    {
        return false;
    }
    bool ok = m_curActivity->stop();

    m_curActivity = NULL;

    emit activityStoped();
    return ok;
}

bool ActivityManager::restart(const QString &activityName)
{
    //TODO
    Activity* temp = activity(activityName);
    if (!temp)
    {
        return false;
    }
    m_curActivity = temp;
    temp->stop();
    temp->start();
    return true;
}

bool ActivityManager::restart(int index)
{
    //TODO
    Activity* temp = activity(index);
    if (!temp)
    {
        return false;
    }
    m_curActivity = temp;
    temp->stop();
    temp->start();
    return true;
}

Activity* ActivityManager::activity(int index)
{
    int size = m_activities.size();
    if (index > size -1)
    {
        return NULL;
    }
    return m_activities[index];
}

Activity* ActivityManager::activity(const QString &name)
{
    foreach(Activity *activity, m_activities)
    {
        if (activity->name() == name)
        {
            return activity;
        }
    }
    return NULL;
}
