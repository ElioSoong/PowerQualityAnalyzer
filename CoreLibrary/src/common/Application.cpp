/****************************************Copyright (c)****************************************************
**
**                                       D.H. InfoTech
**
**--------------File Info---------------------------------------------------------------------------------
** File name:                  Application.cpp
** Latest Version:             V1.0.0
** Latest modified Date:       2016/3/1
** Modified by:                
** Descriptions:               
**
**--------------------------------------------------------------------------------------------------------
** Created by:                 
** Created date:               2016/2/29
** Descriptions:               Application class  [Generated by VP-UML, IGT1.0]
** 
*********************************************************************************************************/
#include "includes.h"
//#include "config.h"
#include "common/Application.h"
#include "common/MetaSystemHelper.h"
#include "gui/MainWindow.h"
#include "FieldLibrary/IField.h"
#include "FieldLibrary/FieldView.h"

#include <QDateTime>
#include <QThread>
#include <QProcess>
#include <stdlib.h> 

#ifdef _WIN32
#include <Windows.h>
#else
#include <sys/statfs.h> 
#include <sys/sysinfo.h>
#include <signal.h>
#include <execinfo.h>
#endif


/*!
 * 构造函数
 * @param[in]    argc	
 * @param[in]    argv	
 */
Application::Application(int& argc, char** argv) 
    : QApplication(argc, argv)
    , m_jsonLoader()
    , m_metaSystemHelper(NULL)
    , m_splash()
    , m_mainWindow(NULL)
    , m_hardwareManager()
{
    
}

/*!
 * 获取软件版本号
 * @return  返回系统软件版本号，硬件版本号，出厂日期，校准日期等
 */
QString Application::version()
{
    return QCoreApplication::applicationVersion();
}

/*!
 * 重启系统
 */
bool Application::reboot()
{
    return m_hardwareManager.reboot();
}

/*!
 * 关闭系统
 */
bool Application::shutdown()
{
    return m_hardwareManager.shutdown();
}

/*! 
 * root权限登录
 * @param[in]  code 登录密码
 * @return     bool 是否登录成功
 */
bool Application::rootLogin( const QString &code )
{
    return m_hardwareManager.rootLogin(code);
}

/*! 
 * root权限登出
 * @return     bool 是否登出成功
 */
bool Application::rootLogout()
{
    return m_hardwareManager.rootLogout();
}

/*!
 * QT的消息handler，可以用于格式化打印信息等特殊操作
 */
void Application::qtMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    QByteArray localMsg = msg.toLocal8Bit();
    const char* localMsgData = localMsg.constData();
    switch (type) 
    {
    case QtDebugMsg:
#ifdef _DEBUG
    case QtWarningMsg:
    case QtCriticalMsg:
#endif
        visualStudioPrintf("%s\n", localMsgData);
        break;
#ifndef _DEBUG
    case QtWarningMsg:
        visualStudioPrintf("Warning: %s (%s:%u, %s)\n", localMsgData, context.file, context.line, context.function);
        break;
    case QtCriticalMsg:
        visualStudioPrintf("Critical: %s (%s:%u, %s)\n", localMsgData, context.file, context.line, context.function);
        break;
#endif
    case QtFatalMsg:
        visualStudioPrintf("Fatal: %s (%s:%u, %s)\n", localMsgData, context.file, context.line, context.function);
        if (!localMsg.isEmpty())
        {
            QString errorMessage;
            errorMessage = QString("Fatal: %1 (%2:%3, %4)").arg(msg).arg(context.file).arg(context.line).arg(context.function);
            emit (static_cast<Application *>(qApp))->error(errorMessage);
        }
        dump(0);
        abort();
    }
}

/*!
 * 系统信号handler，可以用于捕获段错误等
 * @param[in]    signo	 Linux系统信号id
 */
void Application::systemSignalHandler(int signo)
{
}

void Application::dump(int signo)
{
#ifndef _WIN32
    void *array[16];
    size_t size;
    char **strings;
    size_t i;

    static bool isFirstDump = true;
    if (!isFirstDump)
        return;
    isFirstDump = false;

    size = backtrace (array, sizeof(array) / sizeof(array[0]));
    strings = backtrace_symbols (array, size);

    printf ("######## APPLICATION DUMP INFORMATION ########\n");
    printf ("Obtained %zd stack frames (from TOP to BOTTOM):\n", size);

    for (i = 0; i < size; i++)
        printf ("%s\n", strings[i]);

    free (strings);

    if (signo != SIGHUP)
    {
        printf("The system is going to shutdown safely ...\n");
#if 0
        struct statfs diskInfo;  

        statfs(diskPath.toLatin1().constData(), &diskInfo);
        //每个block里包含的字节数  
        quint64 blocksize = diskInfo.f_bsize;    
        //可用空间大小 
        quint64 availableDisk = diskInfo.f_bavail * blocksize; 

        printf ("The Disk Space is %llu M available\n", (availableDisk >> 20));
#endif
        abort();
    }

#else
    Q_UNUSED(signo)
#endif
}

int Application::visualStudioPrintf( const char* fmt, ... )
{
    va_list ap;
    int count = 0;

    va_start(ap, fmt);

#ifdef _MSC_VER
    static char szBuffer[4096];
    count = vsnprintf_s(szBuffer, sizeof(szBuffer) / sizeof(szBuffer[0]), fmt, ap);

    OutputDebugStringA(szBuffer);
#else
    vprintf(fmt, ap);
#endif

    va_end(ap);

    return count;
}

MetaSystemHelper* Application::createMetaSystemHelper()
{
    return new MetaSystemHelper;
}

FieldWidgetCreator* Application::createFieldWidgetCreator()
{
    return new FieldWidgetCreator;
}

QObjectList Application::pluginInstances(const QString& name) const
{
    foreach (PluginList* pluginsOfThisType, m_plugins)
    {
        if (pluginsOfThisType && pluginsOfThisType->name() == name)
        {
            return pluginsOfThisType->instances();
        }
    }

    return QObjectList();
}

QObject* Application::module(const QString& moduleInstanceName) const
{
    QObjectList modules = pluginInstances("modules");
    foreach (QObject* module, modules)
    {
        if (module && module->objectName() == moduleInstanceName)
        {
            return module;
        }
    }

    return NULL;
}

void Application::setPlugins(const QList<PluginList*>& plugins)
{
    // Step1. 清空module动态属性 [5/3/2017 CHENHONGHAO]
    resetModuleProperties();

    // Step2. 更新成员变量
    m_plugins = plugins;

    // Step3. 尝试重新加载
    loadPlugins();

    // Step4. 添加module动态属性
    setModuleProperties();
}

void Application::loadPlugins()
{
    qDebug() << "plugin size : " << m_plugins.size() << " JsonLoader: " << &m_jsonLoader;
    foreach(PluginList* pluginList, m_plugins)
    {
        if (pluginList)
        {
            QString message = QString("Loading %1 plugins from /%2 ...")
                .arg(pluginList->iid())
                .arg(pluginList->name());
            qDebug() << message;
            showSplashMessage(message);
            int loadedPluginCount = pluginList->load(m_jsonLoader);
#if defined(_DEBUG) || 1
            if (loadedPluginCount > 0)
            {
                qDebug() << "# " << loadedPluginCount << "plugins loaded:";
                QObjectList loadedPlugins = this->pluginInstances(pluginList->name());
                for (int i = 0; i < loadedPlugins.count(); ++i)
                {
                    qDebug() << "[" << i << "]" << loadedPlugins[i];
                }
            }
#endif
        }
    }
}

void Application::resetModuleProperties()
{
    QObjectList oldModules = pluginInstances("modules");
    foreach(QObject* oldModule, oldModules)
    {
        if (oldModule)
        {
            this->setProperty(
                oldModule->objectName().toLatin1().constData(),
                QVariant()
                //QVariant::fromValue<QObject*>(oldModule)
                );
            m_jsonLoader.removeGlobalObject(oldModule);
        }
    }
}

void Application::setModuleProperties()
{
    QObjectList newModules = pluginInstances("modules");
    foreach(QObject* newModule, newModules)
    {
        if (newModule)
        {
            QByteArray propName = newModule->objectName().toLatin1();
            const char* chPropName = propName.constData();
            bool isMetaProperty = this->setProperty(
                chPropName,
                QVariant::fromValue<QObject*>(newModule)
                );
            Q_ASSERT(!isMetaProperty);

            QList<QByteArray> dynamicPropertyNames = this->dynamicPropertyNames();

            bool hasDynamicProperty = this->setProperty(
                chPropName,
                QVariant::fromValue<QObject*>(newModule)
                );
            //Q_ASSERT(hasDynamicProperty);

            QVariant result = this->property(chPropName);
            Q_ASSERT(result.value<QObject*>() != NULL);

            m_jsonLoader.addGlobalObject(newModule, false);
        }
    }
}



void Application::setMainWindow(MainWindow* mainWindow)
{
    m_mainWindow = mainWindow;
}

/*!
 * 在欢迎界面上显示文本信息，仅在初始化时使用
 * @param[in]  message 需要显示的文本信息
 */
void Application::showSplashMessage(const QString& message)
{
    m_splash.showMessage(message, Qt::AlignHCenter | Qt::AlignBottom, Qt::white);
}

/*! 
 * 关闭欢迎界面，显示主窗口
 * @return 操作成功返回true
 */
bool Application::showMainWindow()
{
    if (!m_mainWindow)
    {
        m_mainWindow = createMainWindow();
        if (!m_mainWindow)
            return false;
    }

    //m_mainWindow->hide();
    // 由于宏已经移动至具体的项目工程，因此此处无法获得宽高，建议在工厂方法中初始化 [4/20/2017 CHENHONGHAO]
    //m_mainWindow->resize(DEVICE_SCREEN_WIDTH, DEVICE_SCREEN_HEIGHT);
    qDebug("# Painting mainwindow ...");
    //QMetaObject::invokeMethod(m_mainWindow, "navigateHome");
    m_mainWindow->navigateHome();
    m_mainWindow->showWindow();
    m_splash.close();
    //m_splash.finish(m_mainWindow);

    return true;
}

/*!
 * 初始化整个系统，创建各个单例模式对象
 * 注意在此函数中仍可通过this->arguments()获取main函数传入的argv，
 * 并可通过此方式将初始化代码移动至此函数，
 * 从而保持main函数的整洁。
 * @return       操作成功返回true
 */
bool Application::init()
{
    qInstallMessageHandler(qtMessageHandler);

    //连接jsonLoader的error信号
    connect(&m_jsonLoader, SIGNAL(error(int, QString)), this, SLOT(onJsonLoaderError(int, QString)));

#ifndef _WIN32
    signal(SIGSEGV, &dump);
    signal(SIGILL,  &dump);
    signal(SIGABRT, &dump);
    signal(SIGFPE,  &dump);
    signal(SIGBUS,  &dump);
    signal(SIGHUP,  &dump);
#endif

#if 0
    QThread::msleep(60000);
#endif

    qDebug(
        "\n\n\n\n\n"
        "======== " "%s" "========\n"
        "+ APP version:      " "%s" "\n"
        "+ Release time:     " __DATE__ "  " __TIME__ "\n"
        "+ Launch time:      " "%s" "\n"
        "=====================================================\n",
        this->applicationName().toLocal8Bit().constData(),
        this->applicationVersion().toLocal8Bit().constData(),
        QDateTime::currentDateTime().toString("yyyy-mm-dd HH:MM:SS").toLocal8Bit().constData()
        );

    /*
     * @brief 加载欢迎界面
     */
    qDebug("Loading splash-screen page ...");
    m_splash.setPixmap(QPixmap("resources/splash.png"));
    //m_splash.resize(DEVICE_SCREEN_WIDTH, DEVICE_SCREEN_HEIGHT);
    qDebug("Painting splash-screen page ...");
    m_splash.show();

    
    /*
     * @brief 注册各个MetaType
     */
    showSplashMessage(tr("注册元对象 ..."));
    this->setObjectName("A");
    m_jsonLoader.addGlobalObject(this);
    m_metaSystemHelper = this->createMetaSystemHelper();
    if (m_metaSystemHelper && !m_metaSystemHelper->registerAllTypes(m_jsonLoader))
    {
        qCritical() << "Failed to register meta-types.";
        // 忽略此错误，尝试启动，也许只是部分不再使用的类注册失败
        return true;
    }

    FieldWidgetCreator* fWidgetCreator = this->createFieldWidgetCreator();
    if (fWidgetCreator)
    {
        MenuItem::setFieldWidgetCreator(fWidgetCreator);
    }

    showSplashMessage(tr("加载脚本对象 ..."));
    QVariant loadedObjects = m_jsonLoader.load("json/main.json");
    //loadedObjects = m_jsonLoader.load("json/model/activityModel.json");
    
    if (!loadedObjects.isValid())
    {
        qCritical() << "Failed to load JSON objects.";
        // 忽略此错误，尝试启动，也许当前工程根本没有使用JSON
        return true;
    }

    return true;
}

/*!
 * 销毁整个系统
 */
void Application::destroy()
{

}

/*! 
 * 获取jsonLoader的错误提示信息
 * @param[in]  code     错误码
 * @param[in]  message  错误信息
 * @return     void
 */
void Application::onJsonLoaderError(int code, const QString& message)
{
    emit error(QString("code:%1, message:%2").arg(code).arg(message));
}
/*! 
 * 设置设备背光亮度
 * @param[in] brightness 亮度百分比
 * @return 设置成功返回 true，否则返回false
 */
bool Application::setBrightness(int brightness)
{
    return m_hardwareManager.setBrightness(brightness);
}

bool Application::availableDiskSpace( const QString & diskPath )
{
#ifndef WIN32
    struct statfs diskInfo;  

    statfs(diskPath.toLatin1().constData(), &diskInfo);
    //每个block里包含的字节数  
    quint64 blocksize = diskInfo.f_bsize;    
    //可用空间大小 
    quint64 availableDisk = diskInfo.f_bavail * blocksize; 

    printf ("The Disk Space is %llu M available\n", (availableDisk >> 20));
    // 大于32M表示可用
    if ((availableDisk >> 20) > 32)
        return true;
    else
        return false;
#else
    return true;
#endif
}

bool Application::setBuzzer()
{
    return m_hardwareManager.setBuzzer();
}


/*********************************************************************************************************
** End of file
*********************************************************************************************************/
